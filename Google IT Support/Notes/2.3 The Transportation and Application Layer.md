# The Transportation and Application Layer

**Course:** Google IT Support Professional (Certificate Course)  
**Platform:** Coursera  
**Objective:** Understand the roles and interactions of the transport and application layers, including how data is segmented, addressed, transmitted, validated, and delivered to network applications using protocols such as TCP and UDP, along with the mechanisms that ensure reliability, performance, and secure communication.

---

## Introduction to the Transportation and Application Layers

- **Transport Layer** - Allows traffic to be directed to specific network application.

- **Application Layer** - Allows these applications to communicate in a way they understand.

---

## The Transportation Layer

The transport layer is responsible for lots of important functions of reliable computer networking. These include **multiplexing** and **demultiplexing** traffic. Establishing long running connections and ensuring data integrity through error checking and data verification.

- **Multiplexing** in the transport layer means that nodes on a network have the ability to direct traffic toward many different receiving services. 
- **Demultiplexing** is the same concept just at the receiving end. It's taking traffic that's all aimed at the same node and delivering it to the proper receiving service. The transport layer handles multiplexing and demultiplexing through ports. 

- **Port** - A 16 bit number that's used to direct traffic to specific services running on a networked computer.

  - Ports are represented by a single 16-bit number (65535 different port ids)
  - Ports are split up by the IANA (Internet Assigned Numbers Authority) into three categories: System Ports (ports 1-1023), User Ports (ports 1024-49151), and Ephemeral (Dynamic) Ports (ports 49152-65535).
  - A socket is a port that a TCP segment has activated to listen for data requests.
  - Ports allow services to send data to your computer but can also send malware into a client program. It's important to secure your ports.

Different network services run while listening on specific ports for incoming requests. 

For example, the traditional port for HTTP or unencrypted web traffic is port 80. For example, the traditional port for HTTP or unencrypted web traffic is port 80. If we want to request a web page from a web server running on a computer listening on IP 1 0.1.1.100 the traffic would be directed to port 80 on that computer.

Ports are normally denoted with a colon after the IP address, so the full IP and port in this scenario could be described as 10.1.1.100:80.

When written this way, it's known as a socket address or socket number. The same device might also be running in FTP or File Transfer Protocol Server. 

FTP traditionally listens on port 21, so if you wanted to establish a connection to an FTP server running on the same IP that our example web server was running on, you direct traffic to 10.1.1.100 port 21

![Multiplexing and Demultiplexing](/Google%20IT%20Support/Notes/assets/images/Multiplexing.png)

### Additional Notes on Ports

Three categories of ports
Since a 16-bit number identifies ports, there can be 65,535 of them. Given the number of ports available, they have been divided into three categories by the Internet Assigned Numbers Authority (
IANA.

- **System Ports** are identified as ports 1 through 1023. System ports are reserved for common applications like FTP (port 21) and Telnet over TLS/SSL (port 992). Many still are not assigned. Note: Modern operating systems do not use system ports for outbound traffic.

- **User Ports** are identified as ports 1024 through 49151. Vendors register user ports for their specific server applications. The IANA has officially registered some but not all of them.

- **Ephemeral Ports (Dynamic or Private Ports)** are identified as ports 49152 through 65535. Ephemeral ports are used as temporary ports for private transfers. Only clients use ephemeral ports.

Not all operating systems follow the port recommendations of the IANA, but the IANA registry of assigned port numbers is the most reliable for determining how a specific port is being used.

---

## Dissection of a TCP Segment

Just like how an **Ethernet frame** encapsulates an **IP datagram**, an **IP datagram** encapsulates a **TCP segment**. 
- Remember that an Ethernet frame has a payload section, which is really just the entire contents of an IP datagram. 
- Remember also that an IP datagram has a payload section, and this is made up of what's known as a TCP segment.

- **TCP Segment** - Made up of a TCP header and a data section. 
    - This data section is just another payload area for where the application layer places its data. 
    - A TCP header itself is split into lots of fields containing lots of information.

![TCP Header](/Google%20IT%20Support/Notes/assets/images/TCP_Header.png)

- **Destination Port** - is the port of the service the traffic is intended for.

- **Source Port** - is a high-numbered port chosen from a special section of ports known as ephemeral ports.
  - A source port is required to keep lots of outgoing connections separate.
  - A source port is needed so that when the web server replies, the computer making the original request can send this data to the program that was actually requesting it.

- **Sequence Number** - A 32-bit number that's used to keep track of where in a sequence of TCP segments this one is expected to be. 

An Ethernet frame is usually limited in size to 1,518 bytes, but we usually need to send way more data than that. At the transport layer, TCP splits all of this data up into many segments. 

![TCP](/Google%20IT%20Support/Notes/assets/images/TCP.png)

- **Sequence Number** - Used to keep track of which segment out of many this particular segment might be. 

- **Acknowledgment Number** - The number of the next expected segment.  
    - In very simple language, a sequence number of one and an acknowledgment number of two could be read as this is segment 1, expect segment 2 next. The data offset field comes next.

- **Data Offset Field** - A 4-bit number that communicates how long the TCP header for this segment is.
    - This is so that the receiving network device understands where the actual data payload begins.

Then we have six bits that are reserved for the six TCP control flags. The next field is a 16-bit number known as the TCP window. 

- **TCP Window** - Specifies the range of sequence numbers that might be sent before an acknowledgment is required. 
    - TCP is a protocol that's super reliant on acknowledgments. 
    - This is done in order to make sure that all expected data is actually being received and that the sending device doesn't waste time sending data that isn't being received. 

The next field is a **16-bit checksum**. It operates just like the checksum fields at the IP and Ethernet level. Once all of a segment has been ingested by a recipient, the checksum is calculated across the entire segment and is compared with the checksum in the header to make sure that there was no data lost or corrupted along the way. 

The **urgent** pointer field is used in conjunction with one of the TCP control flags to point out particular segments that might be more important than others. ***This is a feature of TCP that hasn't really ever seen adoption, and you'll probably never find it in modern networking.***

Next up, we have the **options** field. ***Like the urgent pointer field, this is rarely used in the real world, but it's sometimes used for more complicated flow control protocols.*** 

Finally, we have some padding, which is just a sequence of zeros to ensure that the data payload section begins at the expected location.

---

## TCP Control Flags & The Three-way Handshake

As a protocol, TCP establishes connections used to send long chains of segments of data. The way TCP establishes a connection is through the use of different TCP control flags used in a very specific order.

### The 6 TCP Flags

1) **URG (urgent)** -A value of one here indicates that the segment is considered urgent and that the urgent pointer field has more data about this. 
    - ***This feature of TCP has never really had widespread adoption and isn't normally seen.***
2) **ACK (acknowledged)** - A value of one in this field means that the acknowledgement number field should be examined.
3) **PSH (push)** - The transmitting device wants the receiving device to push currently buffered data to the application on the receiving end as soon as possible.
    - In some cases, you might be sending a very small amount of information that you need the listening program to respond to immediately. This is what the push flag does.
4) **RST (reset)** - One of the sides in a TCP connection hasn't been able to properly recover from a series of missing or malformed segments. 
    - It's a way for one of the partners in a TCP connection to basically say, wait, I can't put together what you mean. Let's start over from scratch.
5) **SYN (synchronize)** - It's used when first establishing a TCP connection and makes sure the receiving end knows to examine the sequence number field.
6) **FIN (finish)** - When this flag is set to one, it means the transmitting computer doesn't have any More data to send and the connection can be closed.

### The Three-way Handshake

- **Handshake** - A way for two devices to ensure that they're speaking the same protocol and will be able to understand each other.

![The Three-way Handshake](/Google%20IT%20Support/Notes/assets/images/Three-way_Handshake.png)

For a good example of how TCP control flags are used, let's check out how a TCP connection is established. Computer A will be our transmitting computer and computer B will be our receiving computer. 

1) To start the process off, computer A sends a TCP segment to computer B with a **SYN flag sent**. This is computer A's way of saying, let's establish a connection and look at my sequence number field so we know where this conversation starts. 
2) Computer B then responds with a TCP segment where both the **SYN and ACK flags are set**. This is computer B's way of saying, sure, let's establish a connection and I acknowledge your sequence number. 
3) Then computer A responds again with just the **ACK flag set**, which is just saying I acknowledge your acknowledgement.

Once the three-way handshake is complete, the TCP connection is established. Now computer A is free to send whatever data it wants to computer B and vice versa. Since both sides have now sent SYN/ACK pairs to each other, a TCP connection in this state is operating in full duplex. Each segment sent in either direction should be responded to by a TCP segment with the ACK field set. This way, the other side always knows what has been received. 

![The Four-way Handshake](/Google%20IT%20Support/Notes/assets/images/Four-way_Handshake.png)

Once one of the devices involved with the TCP connection is ready to close the connection, something known as a **Four-way Handshake** happens. The computer ready to close the connection sends a FIN flag, which the other computer acknowledges with an ACK flag.

---

## TCP Socket States

- **Socket** - The instantiation of an endpoint in a potential TCP connection. 

- **Instantiation** - The actual implementation of something defined elsewhere. 

TCP sockets require actual programs to instantiate them. You can contrast this with a port, which is more of a virtual descriptive thing. In other words, you can send traffic to any port you want, but you're only going to get a response if a program has opened a socket on that port. 

### TCP Sockets States  
- **LISTEN** - A TCP socket is ready and listening for incoming connections. ***You'd see this on the server side only.*** 
- **SYN_SENT** A synchronization request has been sent, but the connection hasn't been established yet. ***You'd see this on the client side only.*** 
- **SYN_RECEIVED** -A socket previously in a listen state has received a synchronization request and sent a SYN/ACK back. 
  - But it hasn't received the final ACK from the client yet. ***You'd see this on the server side only.*** 

- **ESTABLISHED** - The TCP connection is in working order and both sides are free to send each other data. ***You'd see this state on both the client and server sides of a connection.***
- **FIN_WAIT** - This means that a FIN has been sent, but the corresponding ACK from the other end hasn't been received yet. 
- **CLOSE_WAIT** -This means that the connection has been closed at the TCP layer, but that the application that opened the socket hasn't released its hold on the socket yet. 
- **CLOSED** - This means that the connection has been fully terminated and that no further communication is possible. 

There are other TCP socket states that exist. Additionally, socket states and their names can vary from operating system to operating system. 

That's because they exist outside of the scope of the definition of TCP itself. TCP, as a protocol is universal in how it's used since every device speaking the TCP protocol has to do this in the exact same way for communications to be successful. Choosing how to describe the state of a socket at the operating system level isn't quite as universal. When troubleshooting issues at the TCP layer, make sure you check out the exact socket state definitions for the systems you're working with. 

---

## Connection-oriented & Connectionless Protocol 

- **Connection-oriented Protocol** - Establishes a connection and uses this to ensure that all data has been properly transmitted.

### What happens if checksum doesn't compute at the IP or Ethernet level?

That's entirely up to the transport layer protocol. At the IP or Ethernet level, if a checksum doesn't compute, all of that data is just discarded. It's up to TCP to determine when to resend this data. Since TCP expects an ACK for every bit of data it sends, it's in the best position to know what data successfully got delivered and can make the decision to resend a segment if needed. This is another reason why sequence numbers are so important. 

While TCP will generally send all segments in sequential order, they may not always arrive in that order. If some of the segments had to be reset due to errors at lower layers, it doesn't matter if they arrive slightly out of order. This is because sequence numbers allow for all of the data to be put back together in the right order.

### User Data Cram Protocol (UDP)

Unlike TCP, UDP doesn't rely on connections and it doesn't even support the concept of an acknowledgement. With UDP, you just set a destination port and send the packet. This is useful for messages that aren't super important. 

- **Example** - Video Streaming: If a few frames get lost in transit, you will still have a good streaming experience. Also, it will be faster because bandwidth is used mostly for data transfer instead of establishing and acknowledging connections.

---

## Firewalls

- **Firewalls** - A device that block traffic that meets certain criteria. 
  - Firewalls can actually operate at lots of different layers of the network. There are firewalls that can perform inspection of application layer traffic and firewalls that primarily deal with blocking ranges of IP addresses. They're most commonly used at the transportation layer. 
  
Firewalls that operate at the transportation layer will generally have a configuration that enables them to block traffic to certain ports while allowing traffic to other ports. 

Firewalls are sometimes independent network devices, but it's really better to think of them as a program that can run anywhere. For many companies and almost all home users, the functionality of a router and a firewall is performed by the same device, and firewalls can run on individual hosts instead of being a network device. 

All major modern operating systems have firewall functionality built in. That way, blocking or allowing traffic to various ports and therefore to specific services can be performed at the host level as well. 

---

## The Application Layer

At the network layer, use of IP is everywhere you look. At the transport layer, TCP and UDP cover most of the use cases. But at the application layer, there are just so many different protocols in use that it wouldn't make sense for us to cover them. Even so, application layer protocols are still standardized across application types. Let's dive a little deeper into web servers and web browsers, for an example. There are lots of different web browsers. 

---

## The OSI (Open Systems Interconnection) Model

The **OSI or Open Systems Interconnection Model** is important to understand with our **Five-layer model** because it's the most rigorously defined. That means it's often used in academic settings or by various network certification organizations.

![The OSI Model](/Google%20IT%20Support/Notes/assets/images/OSI_Model.png)

The OSI model has seven layers and introduces two additional layers between our transport layer and our application layer. 

- **Session Layer** - Responsible for things like facilitating the communication between actual applications and the transport layer.

    It's the part of the operating system that takes the application layer data that's been unencapsulated from all the layers below it and hands it off to the next layer in the OSI model, the presentation layer.

- **Presentation Layer** -  Responsible for making sure that the unencapsulated application layer data is actually able to be understood by the application in question.

